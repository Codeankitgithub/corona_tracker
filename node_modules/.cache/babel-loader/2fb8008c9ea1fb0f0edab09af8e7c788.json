{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar getMappedClassNameProps = function getMappedClassNameProps(props, extraProps, namesMap) {\n  var mappedProps = {};\n  var propsToMap = Object.keys(props).filter(function (key) {\n    return key === 'className' || extraProps.includes(key);\n  });\n  propsToMap.forEach(function (key) {\n    mappedProps[key] = mapAndMergeClassNames(props[key], namesMap);\n  });\n  return propsToMap.length ? mappedProps : null;\n};\n\nvar mapAndMergeClassNames = function mapAndMergeClassNames(className, namesMap) {\n  var namesArray = Array.isArray(className) ? className : [className];\n  var splitNamesArr = namesArray.flatMap(function (name) {\n    return splitClassName(name);\n  });\n  return splitNamesArr.map(function (name) {\n    var _namesMap$name;\n\n    return (_namesMap$name = namesMap[name]) != null ? _namesMap$name : name;\n  }).join(' ');\n};\n\nvar splitClassName = function splitClassName(className) {\n  return className.split(/\\s+/g);\n};\n\nvar patchClassNamesOfChildren = function patchClassNamesOfChildren(namesMap, extraProps, children) {\n  var childOrChildren = patchClassNamesWithChildrenMap(namesMap, extraProps, children);\n\n  if (!Array.isArray(children) && !React.isValidElement(children)) {\n    return children;\n  }\n\n  try {\n    React.Children.only(children);\n    return Array.isArray(childOrChildren) ? childOrChildren[0] : childOrChildren;\n  } catch (err) {\n    return childOrChildren;\n  }\n};\n\nvar patchClassNamesWithChildrenMap = function patchClassNamesWithChildrenMap(namesMap, extraProps, children) {\n  return React.Children.map(children, function (child) {\n    if (!React.isValidElement(child)) {\n      return child;\n    }\n\n    return patchClassNamesForReactNode(child, namesMap, extraProps);\n  });\n};\n\nvar patchClassNamesForReactNode = function patchClassNamesForReactNode(child, namesMap, extraProps) {\n  var allMappedOrPatchedProps = getAllMappedOrPatchedProps(child.props, extraProps, namesMap);\n  var patchedChildren = patchClassNamesOfChildren(namesMap, extraProps, child.props.children);\n  var hasValidChildren = React.Children.toArray(child.props.children).some(function (node) {\n    return React.isValidElement(node);\n  });\n\n  if (!allMappedOrPatchedProps && !hasValidChildren) {\n    return child;\n  }\n\n  return React.cloneElement(child, allMappedOrPatchedProps != null ? allMappedOrPatchedProps : {}, patchedChildren);\n};\n\nvar getAllMappedOrPatchedProps = function getAllMappedOrPatchedProps(props, extraProps, namesMap) {\n  var mappedClassNameProps = getMappedClassNameProps(props, extraProps, namesMap);\n  var patchedNodeProps = getPatchedNodeProps(props, extraProps, namesMap);\n\n  if (!mappedClassNameProps && !patchedNodeProps) {\n    return null;\n  }\n\n  return _extends({}, mappedClassNameProps, patchedNodeProps);\n};\n\nvar getPatchedNodeProps = function getPatchedNodeProps(props, extraProps, namesMap) {\n  var patchedNodeProps = {};\n  var propsToMap = Object.keys(props).filter(function (key) {\n    return React.isValidElement(props[key]);\n  });\n  propsToMap.forEach(function (key) {\n    patchedNodeProps[key] = patchClassNamesForReactNode(props[key], namesMap, extraProps);\n  });\n  return propsToMap.length ? patchedNodeProps : null;\n};\n\nvar PatchStyles = function PatchStyles(_ref) {\n  var classNames = _ref.classNames,\n      extraProps = _ref.extraProps,\n      children = _ref.children;\n\n  if (!children) {\n    throw new Error('ApplyStyles should always have children to apply styles too');\n  }\n\n  var extraPropsArr = Array.isArray(extraProps) ? extraProps : [extraProps];\n  var extraPropsSplit = extraPropsArr.flatMap(function (props) {\n    return (props != null ? props : '').split(/\\s*,\\s*/g);\n  });\n  return React.createElement(React.Fragment, null, patchClassNamesOfChildren(classNames, extraPropsSplit, children));\n};\n\nexport default PatchStyles;","map":{"version":3,"sources":["../src/helper-methods/get-mapped-class-name-props.ts","../src/helper-methods/patch-class-names-of-children.ts","../src/index.tsx"],"names":["getMappedClassNameProps","mappedProps","propsToMap","key","extraProps","mapAndMergeClassNames","props","namesArray","Array","splitNamesArr","splitClassName","namesMap","className","patchClassNamesOfChildren","childOrChildren","patchClassNamesWithChildrenMap","React","patchClassNamesForReactNode","allMappedOrPatchedProps","getAllMappedOrPatchedProps","child","patchedChildren","hasValidChildren","mappedClassNameProps","patchedNodeProps","getPatchedNodeProps","PatchStyles","classNames","children","extraPropsArr","extraPropsSplit"],"mappings":"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","sourcesContent":["import { ClassNamesMap } from '../utils';\n\nconst getMappedClassNameProps = <T>(props: T, extraProps: string[], namesMap: ClassNamesMap): Partial<T> | null => {\n  const mappedProps: T = <T>{};\n  const propsToMap = Object.keys(props).filter((key) => key === 'className' || extraProps.includes(key));\n\n  propsToMap.forEach((key) => {\n    mappedProps[key] = mapAndMergeClassNames(props[key], namesMap);\n  });\n\n  return propsToMap.length ? mappedProps : null;\n};\n\nexport default getMappedClassNameProps;\n\nconst mapAndMergeClassNames = (className: string | string[], namesMap: ClassNamesMap): string => {\n  const namesArray = Array.isArray(className) ? className : [className];\n  const splitNamesArr = namesArray.flatMap((name) => splitClassName(name));\n\n  return splitNamesArr.map((name) => namesMap[name] ?? name).join(' ');\n};\n\nconst splitClassName = (className: string): string[] => {\n  return className.split(/\\s+/g);\n};\n","import React, { PropsWithChildren, ReactElement, ReactNode } from 'react';\nimport { ChildPropsType, ClassNamesMap } from '../utils';\nimport getMappedClassNameProps from './get-mapped-class-name-props';\n\nconst patchClassNamesOfChildren = (namesMap: ClassNamesMap, extraProps: string[], children: ReactNode): ReactNode => {\n  const childOrChildren = patchClassNamesWithChildrenMap(namesMap, extraProps, children);\n\n  if (!Array.isArray(children) && !React.isValidElement(children)) {\n    return children;\n  }\n\n  try {\n    React.Children.only(children);\n    return Array.isArray(childOrChildren) ? childOrChildren[0] : childOrChildren;\n  } catch (err) {\n    return childOrChildren;\n  }\n};\n\nexport default patchClassNamesOfChildren;\n\nconst patchClassNamesWithChildrenMap = (namesMap: ClassNamesMap, extraProps: string[], children: ReactNode): ReactNode => {\n  return React.Children.map<ReactNode, ReactNode>(children, (child: ReactNode) => {\n    if (!React.isValidElement<PropsWithChildren<ChildPropsType>>(child)) {\n      return child;\n    }\n\n    return patchClassNamesForReactNode(child, namesMap, extraProps);\n  });\n};\n\ntype ChildElement = ReactElement<PropsWithChildren<ChildPropsType>>;\n\nconst patchClassNamesForReactNode = (child: ChildElement, namesMap: ClassNamesMap, extraProps: string[]): ReactNode => {\n  const allMappedOrPatchedProps = getAllMappedOrPatchedProps(child.props, extraProps, namesMap);\n  const patchedChildren = patchClassNamesOfChildren(namesMap, extraProps, child.props.children);\n\n  const hasValidChildren = React.Children.toArray(child.props.children).some((node) => React.isValidElement(node));\n\n  if (!allMappedOrPatchedProps && !hasValidChildren) {\n    return child;\n  }\n\n  return React.cloneElement(child, allMappedOrPatchedProps ?? {}, patchedChildren);\n};\n\nconst getAllMappedOrPatchedProps = <T>(props: T, extraProps: string[], namesMap: ClassNamesMap): Partial<T> | null => {\n  const mappedClassNameProps = getMappedClassNameProps(props, extraProps, namesMap);\n  const patchedNodeProps = getPatchedNodeProps(props, extraProps, namesMap);\n\n  if (!mappedClassNameProps && !patchedNodeProps) {\n    return null;\n  }\n\n  return {\n    ...mappedClassNameProps,\n    ...patchedNodeProps,\n  };\n};\n\nconst getPatchedNodeProps = <T>(props: T, extraProps: string[], namesMap: ClassNamesMap): Partial<T> | null => {\n  const patchedNodeProps: T = <T>{};\n  const propsToMap = Object.keys(props).filter((key) => React.isValidElement(props[key]));\n\n  propsToMap.forEach((key) => {\n    patchedNodeProps[key] = patchClassNamesForReactNode(props[key], namesMap, extraProps);\n  });\n\n  return propsToMap.length ? patchedNodeProps : null;\n};\n","import React, { FC, PropsWithChildren } from 'react';\nimport { ClassNamesMap } from './utils';\nimport patchClassNamesOfChildren from './helper-methods/patch-class-names-of-children';\n\nexport interface Props {\n  classNames: ClassNamesMap;\n  extraProps?: string | string[] | null;\n}\n\nconst PatchStyles: FC<PropsWithChildren<Props>> = ({ classNames, extraProps, children }) => {\n  if (!children) {\n    throw new Error('ApplyStyles should always have children to apply styles too');\n  }\n\n  const extraPropsArr = Array.isArray(extraProps) ? extraProps : [extraProps];\n  const extraPropsSplit = extraPropsArr.flatMap((props) => (props ?? '').split(/\\s*,\\s*/g));\n\n  return (\n    <React.Fragment>\n      {patchClassNamesOfChildren(classNames, extraPropsSplit, children)}\n    </React.Fragment>\n  );\n};\n\nexport default PatchStyles;\n"]},"metadata":{},"sourceType":"module"}